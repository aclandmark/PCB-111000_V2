
/*Proj_1C and Proj_1C1 Pin_Change_Interrupt
*************************************************************/

/*PROGRAM 3 A REACTION TIME TESTER
Test your reactions by attempting to shoot the LEDS down using the middle pcb switch (switch_2).
 


SOME OF THE THINGS THIS PROGRAM INTRODUCES:


1.	Interrupts	(Signals generated by the Atmega HW):
An interrupt is a signal that interrupts normal program flow, which then temporarily leaves the 
"main" routine and jumps to a special subroutine known as an ISR (Interrupt Service Routine). 
On this PCB Interrupts can be generated by timers, by pressing a key on the PC or by operating 
one of the project pcbs switches.  At the end of the ISR program flow returns to where it was 
when the interrupt occurred. 

2	"config_sw2_for_PCI"	
This is a project macro that sets up switch_2 to generate Pin Change interrupts (PCI).

3.	ISR(PCINT0_vect){}:
This is the Interrupt Service Routine (ISR) that is called every time sw_2 is pressed or released.
Note that program flow returns immediately when the switch is released so that it is only switch 
presses that have any effect.

4.	Global variables: 
Note that variables "PORT_1" and "mask" are available to both the "main" routine and also to the ISR.

5.	More complex logic:
Not really of interest at this stage.
This has been added in an attempt to produce something interesting and its study may usefully be delayed.

6.	The statement "if(m == 1)" which means execute the next statement if m equals 1,
but if it equals anything else skip the next statement.

7.	A programmer bug (A minor issue with the Project soft ware (SW)):
It should be possible to write the first line of "c" as "unsigned int PORT_1, mask = 0xFFFF;" 
However if this is done the resulting .hex file fails to download to the Atmega 168 correctly.
It is therefore necessary to initialise "mask" inside the main routine.*/





//The program starts here




#include "Proj_1C_header_file.h"



unsigned int PORT_1, mask;			//PROGRAMMER BUG: Do NOT define mask here as 0xFFFF as programmer then fails

int main (void){
setup_HW;
config_sw2_for_PCI;					//Enable PCI interrupt on switch_2				 

mask = 0xFFFF;						//0xFFFF = 0b1111111111111111 indicating that none of the leds have yet been shot down
sei();								//Global enable all interrupts (required in addition to "config_sw2_for_PCI")						
while(mask){						//Exit the "while-loop" as soon as mask gets set to zero
PORT_1=1;							//Initialise display to 0000 0000 0000 0001

for(int m = 1; m < 17; m++){		//Repeat "for-loop" 16 times
									//LOGIC: "Dead" leds are transferred to the bottom row
I2C_Tx_2_integers(PORT_1 & mask, (~mask) ^ PORT_1);
 
Timer_T0_10mS_delay_x_m(10);		//Program execution spends most time waiting here, so this is where the interrupt almost always occurs						
PORT_1 = (PORT_1 << 1);			//Move on to next display location			
}}I2C_Tx_2_integers(0, 0xFFFF);	//When all leds are dead illuminate all the bottom leds and then
Timer_T0_10mS_delay_x_m(100);		//pause for 1 sec before starting all over again.			 
SW_reset;}



/**************Routine executed every time that switch is  operated**************************************/
									
ISR(PCINT0_vect) {					//This ISR momentarily interrupts the main routine
if(switch_2_up)return;				//It notes which LED has just been shot down and 
mask &= ~PORT_1;}					//writes zero at its location in the "mask" register





/*
MORE ON THE LOGIC

the "^" symbol know as Exclusive-OR is similar to OR except the 1 ^ 1 = 0 where as 1 | 1 = 1
For example 10101010 ^ 11110000 = 01011010


Variable "mask" starts of as 1111111111111111
Assume that sw2 is pressed when PORT_1 is 0000000000000100
~PORT_1 is 1111111111111011 and
mask which is set to mask & ~PORT_1 becomes 
1111111111111111 & 1111111111111011 = 1111111111111011

Assume that sw2 is pressed again when PORT_1 is 0000000000000010
mask now becomes 1111111111111011 & 1111111111111101 = 1111111111111001

After pressing sw2 several times assume that the mask is
1111111111000011 and therefore ~mask is 0000000000111100

PORT_1 & mask is zero for the following values of PORT_1
0000000000000100, 0000000000001000, 0000000000010000 and 0000000000100000
Therefore the upper half of the display skips leds numbered 2,3,4 and 5 counting from zero 
i.e those that have been shot down

"(~mask) ^ PORT_1" is always 1 for leds numbers 2,3,4 and 5 
except for the following values of PORT_1 
0000000000000100, 0000000000001000, 0000000000010000 and 0000000000100000

i.e. the lower half of the display remembers the leds that have been shot down
Note however that the lower leds flicker when their upper companion is passed by
 */                                                   