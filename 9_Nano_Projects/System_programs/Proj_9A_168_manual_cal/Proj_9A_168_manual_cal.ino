
/*Proj_9A_168_manual_cal
****************************************************************************/



/*In these projects calibration relies on the fact that an 8MHz clock counts up to 62,500 every 7.8125mS 
an interval easily generated by a timer, controlled using a watch crystal.   When calibrating the Atmega 168 
the timer interval triggers an I2C interrupt. When calibrating the Atmega 328 it triggers a timer interrupt. 
This is because the crystal is connected to the Atmega 328.

The exact frequency of the 8MHz clock is determined by the value saved in the OSCCAL register. At reset the 
OSCCAL register is automatically loaded with a value supplied during chip manufacture.  This value can be 
overwritten by project code to provide improved accuracy required for clocks and timers and sometimes even 
to ensure reliable communication with a PC.

This project generates a print out of calibration error as a function of the calibration factor OSCCAL and 
enables the user to choose a value for OSCCAL.


IT INTRODUCES


1.  Project subroutine "I2C_initiate_7_8125mS_ref()".
  This initiates a TWI interrupt from the mini_OS every 7.8125 mS. Note: in a 7.8125mS interval, T1 running 
  at 8MHz counts up to 62,500.
  
2.  Project subroutine ISR(TIMER1_OVF_vect).
  This records the T1 counter error every time that its is called.

3.  Project subroutine "compute_error()".
  This is where program execution pauses, awaiting a TWI interrupt, which assures a suitable warm up period 
  and then averages the error over 10 TWI intervals.

4.  Project subroutine "compute_single_error()".
  This sets up the timers, requests the TWI interrupt and calculates the error independently of the main routine.

5.  Macro "setup_HW_E".
  If x is pressed instead of r at the p/r user prompt this offers a menu that gives the mini-OS and project versions, 
  checks the calibration of the Atmega 328 or gives a demonstration of the multiplexer operation.
*/

#include "Proj_9A_header_file.h"

volatile char T1_OVF;
volatile long error_SUM;
unsigned char OSCCAL_WV, OSCCAL_DV, New_UC_value;
volatile int EA_counter, EA_buff_ptr;
int buffer[41];
char Num_string[12];




int main (void){
long error;
long percentage_error;
setup_HW_Arduino_IO_Extra;                              //"setup_HW"initially saves default OSCCAL in 0x1FD and
OSCCAL_DV = eeprom_read_byte((uint8_t*)0x1FD);          //then checks for "user-cal" and copies it to OSCCAL if present
OSCCAL_WV = OSCCAL;                                     //Save actual cal value: could be "user-cal" or the default OSCCAL

Serial.write("\r\nATMEGA 168 manual \
calibration\r\n\
Cal factor working value   \t");                      //Print the actual (working) value of OSCCAL
Hex_to_PC_A(OSCCAL_WV, Num_string, '\r' );
Serial.write("Cal factor default value   \t");        //Print OSCCAL_default_Value
Hex_to_PC_A(OSCCAL_DV , Num_string, '\r' ); 

Serial.write("Doing calculations. Please wait 10 seconds\r\n");

_delay_ms(25);
TIMSK1 |= (1 << TOIE1);                               //Enable T1 interrupt
I2C_initiate_7_8125mS_ref();                          //Request Mode P: 7.8125mS ref signal from master
  

/*****Waiting for first I2C tick***********/
waiting_for_I2C_master;                             //Energise  slave I2C and wait for master
send_byte_with_Nack(1);                             //Master will respond by staying in mode P
clear_I2C_interrupt;                                //House keeping
TCNT1=0;TCCR1B = 1;                                 //Start T1 with no prescalling (at 8MHz)

OSCCAL -= 20;                                       //Compute cal errors for 40 values of OSCCAL
for(int m = 0; m <= 40; m++){                       //results are stored in array "buffer"
error = compute_error(1);OSCCAL++;}

OSCCAL = OSCCAL_WV;                                 //Restore OSCCAL to safe value for print out
waiting_for_I2C_master;
send_byte_with_Nack(0);                             //Master responds by exiting mode P
clear_I2C_interrupt;
//cli();
TIMSK1 &= (~(1 << TOIE1));                          //Dissable T1 interrupt

for (int m = 0; m <= 40; m++){
Hex_to_PC_A(OSCCAL_WV - 20 + m, Num_string, '\t');  //Serial.write("   \t");
Int_Num_to_PC_A(buffer[m], Num_string, ' '); 
Serial.write("   \t");
percentage_error = buffer[m];
Int_Num_to_PC_A(percentage_error*100/62500, Num_string,'%');
newline_A();}

Serial.write("Enter new user cal value (Use capitol letters)\r\n\
or enter FF to delete the user cal");           //Request new OSCCAL_User_Value

New_UC_value = Hex_from_KBD();
Serial.write ("\r\nPress y if OK or AOK and repeat");

while(1){
if(waitforkeypress_A() == 'y')break; 
else {newline_A();Serial.write('?');
New_UC_value = Hex_from_KBD();Serial.write(" y?");}}




/************Exit if user enters 0xFF*************************/

if(New_UC_value == 0xFF){
  if ((error = compute_single_error(OSCCAL_DV)) > 1000)
  {eeprom_write_byte((uint8_t*)0x1FE, OSCCAL_WV);
eeprom_write_byte((uint8_t*)0x1FF, OSCCAL_WV);
Serial.write("\n\rDefault value not OK");}
else
{eeprom_write_byte((uint8_t*)0x1FE, 0xFF);         //Delete user cal value
eeprom_write_byte((uint8_t*)0x1FF, 0xFF);}
SW_reset;}



/*********Safeguard: Do not accept dangerous cal values*********************/
if ((error = compute_single_error(New_UC_value)) > 1000)    
{newline_A();                 
Int_Num_to_PC_A(error, Num_string, ' ');
Serial.write("  Error too great!"); 
newline_A();
eeprom_write_byte((uint8_t*)0x1FE, OSCCAL_WV);         //Delete user cal value
eeprom_write_byte((uint8_t*)0x1FF, OSCCAL_WV);
SW_reset;}                                        //Abort and automatically repeat calibration process


/*********Safeguard: Cal value entered at KBD is OK*********************/
eeprom_write_byte((uint8_t*)0x1FE, New_UC_value);     //Save new user cal value to EEPROM addresses 0x1F7 and 8
eeprom_write_byte((uint8_t*)0x1FF, New_UC_value);

Serial.write("\r\nValues saved to EEPROM   \t");      //Echo values back from the EEPROM
Hex_to_PC_A(eeprom_read_byte((uint8_t*)0x1FE), Num_string, ' ');
Serial.write ("    ");
Hex_to_PC_A(eeprom_read_byte((uint8_t*)0x1FF), Num_string, '\r');
Serial.write("\r\nAK to repeat\r\n");
waitforkeypress_A();SW_reset;}                        //keypress to repeat cal process



/**********************************************************************************************/
long compute_error(char error_mode) 
    {long error;
    waiting_for_I2C_master_with_ISR;                  //TWI generates interrupt every 7.8125mS 
    EA_counter = 0;                                   //Compute error for each value of OSCCAL 10 times
    error_SUM = 0;
    while(EA_counter < 15);EA_counter = 0;TWCR = 0;   //wait here for 15 TWI interrupts
    error = error_SUM;
    if (error < 0) error *= (-1);                     //Only interested in the magnitude of the error
    if (error_mode)
    {buffer[EA_buff_ptr] = error/10;EA_buff_ptr++;}
    return error/10;}                                 //return average error values
  



/**********************************************************************************************/
ISR(TIMER1_OVF_vect){T1_OVF++; }                  //T1 should count to 62500 in 7.8125ms.

ISR(TWI_vect){                                   //T2 (mini_OS) overflows: giving a calibrated tick rate
long TCNT1_BKP;
TWDR;                                             //Read TWDR the data register
send_byte_with_Nack(1);                           //Master responds by remaining in mode P
clear_I2C_interrupt;

TCCR1B = 0;                                       //Halt T1
TCNT1_BKP = TCNT1;                                //Copy the value of TCNT1
TCNT1 = 0;                                        //Clear TCNT1
TCCR1B = 1;                                       //Get T1 running again ASAP (Note T2 (mini_OS) has not stopped running)
if(EA_counter < 5)T1_OVF = 0;                     //Ignore first 5 results
else                                              //Sum error results for the next 20 TWI interrupts

{if(T1_OVF)                                       //compute error when T1 does and does not overflow
{T1_OVF = 0;
error_SUM = error_SUM + TCNT1_BKP + 3033;}    
else {error_SUM = error_SUM + TCNT1_BKP - 62500;}}
EA_counter++;                                     //counter increments up to 25.

waiting_for_I2C_master_with_ISR;}                 //Be ready for next TWI interrupt 



/**********************************************************************************************/
void I2C_initiate_7_8125mS_ref(void){
char num_bytes=0;
char mode = 'U';
waiting_for_I2C_master;
send_byte_with_Ack(num_bytes);
send_byte_with_Nack(mode);
clear_I2C_interrupt;} 



/**********************************************************************************************/
long compute_single_error(char OSCCAL_TV){         //Trial value
long error;
char SREG_bkp;

SREG_bkp = SREG;
OSCCAL = OSCCAL_TV;                             //Set OSCCAL equal to the trial value           
TIMSK1 |= (1 << TOIE1);                         //Enable T1 interrupt
I2C_initiate_7_8125mS_ref();                    //Request Mode P: 7.8125mS ref signal from master
waiting_for_I2C_master;                         //First 7.8125mS tick
send_byte_with_Nack(1);                         //Master responds by staying in mode P
clear_I2C_interrupt;
TCNT1=0;TCCR1B = 1;                             //Start T1 with no prescalling (at 8MHz)
sei();
error = compute_error(0);
waiting_for_I2C_master;
send_byte_with_Nack(0);                         //Master responds by exiting mode P
clear_I2C_interrupt;
TIMSK1 &= (~(1 << TOIE1));                      //Disable T1 interrupt
SREG = SREG_bkp;
OSCCAL = OSCCAL_WV;                             //Restore safe value of OSCCAL
return error;}
